# 키워드

## 분할 정복

자기 자신을 호출하면서 그 연산 단위를 줄여나가는 것.

- 장점: 문제를 나눔으로서 어려운 문제를 해결할 수 있음.
- 단점: 스택에 다양한 데이터를 보관하고 있어 스텍 오버플로우나, 과도한 메모리를 사용하게 된다. "F(x)가 간단"이라는 것이 가장 중요한데, 이게 어떤 것이 간단한지는 잘 모른다.

## 정렬

### O(N^2)

- 버블 정렬(Bubble Sort)
- 선택 정렬(Selectio Sort)
- 삽입 정렬(Insertion Sort)

### O(n log n)

- 병합 정렬/합병 정렬(Merge Sort)
- 힙 정렬(Heap Sort)
- 퀵 정렬(Quick sort)
- 트리 정렬 (Tree sort)

### 하이브리드 정렬

- 팀 정렬(Tim Sort)
- 블록 병합 정렬(Block Merge Sort)
- 인트로 정렬(Intro Sort)

### Etc

- 기수 정렬(Radix Sort)
- 계수 정렬(Counting Sort)
- 셸 정렬(Shell's Sort)
- 대기 정렬(Sleep Sort)
- 중력 정렬(Gravity Sort)

## 우선순위 큐

특정 우선순위에 따라 요소를 정렬하고, 가장 높은 우선순위를 가진 요소를 빠르게 추출 할 수 있다.

힙은 완전 이진 트리로 구성된 그래프 자료 구조를 사용한다. 여기서는 최소 힙과 최대 힙 2가지 형태가 있는데, 최소 힙은 루트 노드가 가장 작은 값, 최대 힙은 루트 노드가 가장 큰 값을 말한다.

우선순위 큐는 힙 자료구조와 비슷하지만, 요소가 삽입될 대 우선순위에 따라 정렬된다. 따라서 가장 높은 우선순위를 가진 요소가 먼저 추출된다.

우선순위 큐는 작업 스케줄링, 네트워크 패킷 처리, 다익스트라 알고리즘 등 다양한 응용 분야에서 사용된다. 여기서 다익스트라 알고리즘은 Min Heap을 이용하면 O(V^2)에서 O(ElogV)까지 줄일 수 있다.

### 우선순위 큐의 동작과 원리

#### 1. 삽입 연산

1. 트리의 말단 노드에 새로운 값을 삽입한다.
2. 말단에서부터 루트까지 트리를 거슬러 올라가면서 Heapify(up-heap)작업을 수행한다.

#### 2. 삭제 연산

1. 루트 노드를 삭제한다.
2. 말단 노드를 빈 자리에 가져온다.
3. 루트부터 말단까지 내려가면서 Heapify(down-heep) 작업을 수행한다.

## Linked List

Linked listd의 이름은은 노드(node, 마디, 교점)혹은 버텍스(vertext, 정점, 꼭지점)을 말한다. 연결성이 강조된 표현들이다.

아래 그림든 linked list의 구조를 보여준다.

![링크드 리스트 주고](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/1335/2939.png)

이것을 구현하는 방법은 여러가지이다. 보통은 value라는 이름의 변수, 링크 필드는 next라는 변수를 사용한다.

Head는 출입문에 해당하는 것이다.

### 트레이드 오프

Linked List는 추가 및 삭제가 빠르지만, 인덱스 조회가 느리고 Array List는 추가 삭제가 느린 대신 인덱스 조회가 빨르다. 따라서 적절한 사용 방법은 좋은 사용성을 만들어 낼 것이다.

## 해시 테이블

### 해싱이란(Hashing)

해시 함수(Hash Function)을 사용하여 고정된 크기의 값으로 변환하는 작업을 말한다.

### 해시 테이블(Hash Table)

이 해시 함수를 이용하여 변환한 값을 색인(index)로 삼아 키(key)와 데이터(value)를 저장하는 자료구조를 말한다.
기본 연산으로는 탐색(Search), 삽입(Insert), 삭제(Delete)가 있다.

#### 1. Direct Address Table

키 값을 주소로 사용하는 테이블을 말한다. 이런 자료 구조는 탐색, 삽입, 삭제 연산을 모두 O(1)에 할 수 있지만 한계점이 명확하다.

- 최대 키 값에 대해 알고 있어야 한다.
- 최대 키 값이 작을 때 실용적으로 사용할 수 있다.
- 키 값들이 골고루 분포되어있지 않다면 메모리 낭비가 심할 수 밖에 없다.

#### 2. Hash Table

![Hash Table](https://media.geeksforgeeks.org/wp-content/uploads/20200609180838/HashingDataStructure-min.png)

해시 값을 인덱스로 사용하는 함수이다. 여기서 문제가 되는 것은 충돌(Collision)이다. 이에 대해 이야기 하기 전에 먼저 적재율(Load Factor)에 대해 이야기 해야한다.

적재율이란 해시 테이블의 크기 대비, 키의 개수를 말한다. 즉 키의 개수를 K, 해시테이블의 크기를 N이라고 했을 때 적재율은 K/B을 말한다. 예를 들어 Direct Address Table은 키 값을 인덱스를 사용하는 구조이긴 때문에 적재율이 1 이하이며 적재율이 1 초과인 해시 테이블의 경우에는 반드시 충돌이 발생한다.

충돌이 발생할 경우 삭제 연산이 최악에 O(K)만큼 걸리게 된다. 그래서 충돌을 줄여서 연산 속도를 빠르게 하는 것이 해시 테이블의 핵심이다.

따라서 이 충돌을 완화하는 것이 2가지 방식이 있다.

- 해시 테이블의 구조 개선
- 해시 함수 개선

#### 충돌 해결 1: 해시 테이블의 구조 개선

1. Chaining: 데이터가 충돌할 때 Bucket으로 따로 만들어서 넣을 수 있다.
2. Open Addressing: 데이터 충돌이 있을 때 다른 주소로 이동할 수 있게 하는 기법
    1. 선형 탐사(Linaer Probing): 선형 탐사는 인접한 인덱스에 데이터를 삽입한다. 대문에 데이터가 밀집되는  클러스터링(Clustring)문제가 나오게 되고 이로 인해 탐색과 삭제가 느려진다.
    2. 제곱 탐사(Quadratic Probing): 선형 탐사에 비해 더 폭 넓게 탐사하기 때문에 선형보단 탐색과 삭제에 효율적일 수 있다. 하지만 클러스터링의 문제에서 벗어나지는 못한다.
    3. 이중 해싱(Double Hashing): 처음 해시 함수로 해시값을 찾기 위해 사용하고, 두번째 해시 함수는 충돌 발생시 탐사 폭을 계산하기 위해 사용되는 방식.

#### 충돌 해결 2: 해시 함수 개선

1. 나눗셈법(Division Method): h(k) = k mod N
2. 접기법(Fording Method): 검색키 분해하고 조합하여 해시 만들기
    1. 이동 접기(Shift folding): 자리수대로 분해하고 더한 이후, 초과한 자리는 버리기
    2. 경계 접기(Boundary folding): 자리수대로 분해하고, 경계를 역으로 정렬한 뒤 더하기. 초과한 자리는 버리기
3. 곱셈법(Multiplication Method): h(k) = N= (kA mod 1)의 아래값
4. 중간 제곱 법(Mid-Square Method): 키를 제곱한 이후 중간에 있는 비트만 선택하여 해시로 사용하기

이 해시 함수를 개선하는데 있어서 크게 2가지 특성을 만족 시켜야 한다.

- 효율적인 계산: 복잡한 계산이 이러나면 안된다.
- 보안의 특성
  - 제 1역상 저항성(Preimage resistance): 해시값을 이용해 원래의 값을 알 수 없어야 한다.
  - 제 2역상 저항성(2nd preimage resistance): 여러 값을 넣어서 같은 해시 값의 나오는 값을 찾아내는 것이 불가능해야 한다.
  - 충돌 저항성(Collision resistance): 해시 함수의 결과값이 같은 두 값을 알아낼 수 없어야 한다.

추가적인 예시로는 다음과 같다.

1. MD5: 임이의 길이의 값을 받아 128비트의 출력 값을 나타낸다.
2. SHA-1: 임이의 길이를 입력 받아 160 배트의 출력 값을 낸다.
3. Keccak: 스펀지 구조로 이루어져 있어 SHA-3표준 알고리즘이다.
